<!doctype html>
<html lang="ar">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Matrix Tiles — Pop Effect</title>
<style>
  html,body { height:100%; margin:0; background:#000; overflow:hidden; font-family: monospace; }
  canvas { display:block; width:100%; height:100%; }
  .overlay {
    position:fixed; left:50%; top:46%; transform:translate(-50%,-50%);
    text-align:center; color:#fff; z-index:10; pointer-events:none;
  }
  .danger {
    font-size:44px; font-weight:700; color:#ff4b4b;
    text-shadow:0 0 18px rgba(255,0,0,0.6);
    pointer-events:auto; cursor:pointer;
  }
  .sub { margin-top:10px; font-size:14px; color:#ccc; }
  .note { position:fixed; bottom:8px; left:50%; transform:translateX(-50%); color:#777; font-size:12px; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="overlay" id="overlay">
  <div class="danger" id="danger">⚠️ لقد تم اختراق جهازك ⚠️</div>
  <div class="sub">(اضغط على النص لتوقيف/استئناف) — مزحة فقط</div>
</div>

<div class="note">Press ESC to stop / Click the message to pause</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let w = canvas.width = innerWidth;
  let h = canvas.height = innerHeight;

  // Settings
  const fontSize = 18;
  const tileCols = Math.max(6, Math.floor(w / 240)); // number of tile columns (responsive)
  const tileRows = Math.max(4, Math.floor(h / 180)); // number of tile rows
  const tileGap = 8; // gap between tiles in px
  const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$%&*';
  const maxStreamLen = 14; // how many chars per stream in a tile
  const speedMin = 0.6;
  const speedMax = 1.6;
  const particleCount = 12;

  // Derived
  let tileW, tileH;
  function recalcTiles() {
    tileW = Math.floor((w - tileGap*(tileCols+1)) / tileCols);
    tileH = Math.floor((h - tileGap*(tileRows+1)) / tileRows);
  }
  recalcTiles();

  window.addEventListener('resize', () => {
    w = canvas.width = innerWidth;
    h = canvas.height = innerHeight;
    recalcTiles();
    init();
  });

  // Tile class
  class Tile {
    constructor(col, row) {
      this.col = col; this.row = row;
      this.x = tileGap + col * (tileW + tileGap);
      this.y = tileGap + row * (tileH + tileGap);
      this.resetStream();
      this.particles = [];
    }
    resetStream() {
      this.stream = [];
      const len = 3 + Math.floor(Math.random() * maxStreamLen);
      for (let i=0;i<len;i++) this.stream.push({ch: randomChar(), y: -i * fontSize});
      this.speed = speedMin + Math.random() * (speedMax - speedMin);
      this.active = true;
    }
    update(dt) {
      if (!this.active) return;
      // move stream
      for (let s of this.stream) s.y += this.speed * dt;
      // if head passed bottom of tile => pop
      const headY = this.stream[this.stream.length-1].y;
      if (headY > this.y + tileH - fontSize/2) {
        this.pop();
        this.active = false;
        // schedule reset after short delay
        setTimeout(() => { this.resetStream(); }, 300 + Math.random()*1200);
      }
      // update particles
      for (let p of this.particles) {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= dt * 0.02;
      }
      // remove dead particles
      this.particles = this.particles.filter(p => p.life>0);
    }
    draw(ctx) {
      // draw tile background subtle
      ctx.fillStyle = 'rgba(0,0,0,0.36)';
      ctx.fillRect(this.x, this.y, tileW, tileH);

      // draw border
      ctx.strokeStyle = 'rgba(0,120,60,0.12)';
      ctx.strokeRect(this.x, this.y, tileW, tileH);

      // clip to tile
      ctx.save();
      ctx.beginPath();
      ctx.rect(this.x, this.y, tileW, tileH);
      ctx.clip();

      // draw stream chars
      for (let i=0;i<this.stream.length;i++) {
        const s = this.stream[i];
        const px = this.x + fontSize/2;
        const py = this.y + Math.floor(s.y);
        // head bright
        ctx.fillStyle = 'rgba(180,255,180,1)';
        ctx.fillText(s.ch, px, py);
        // trail slightly darker above
        ctx.fillStyle = 'rgba(0,150,70,0.28)';
        ctx.fillText(s.ch, px, py - fontSize);
      }

      // draw particles (pop)
      for (let p of this.particles) {
        ctx.fillStyle = `rgba(180,255,180,${Math.max(0, p.life)})`;
        ctx.fillText(p.ch, p.x, p.y);
      }

      ctx.restore();
    }
    pop() {
      // create particles at bottom center of tile
      const cx = this.x + tileW/2;
      const cy = this.y + tileH - fontSize;
      for (let i=0;i<particleCount;i++) {
        const angle = Math.random()*Math.PI*2;
        const speed = 0.5 + Math.random()*2.2;
        this.particles.push({
          ch: randomChar(),
          x: cx + (Math.random()-0.5)*20,
          y: cy + (Math.random()-0.5)*6,
          vx: Math.cos(angle)*speed,
          vy: Math.sin(angle)*speed - 0.5,
          life: 1.0 + Math.random()*0.8
        });
      }
    }
  }

  function randomChar() {
    return chars.charAt(Math.floor(Math.random()*chars.length));
  }

  let tiles = [];

  function init() {
    tiles = [];
    // set font
    ctx.font = fontSize + 'px monospace';
    for (let r=0;r<tileRows;r++) {
      for (let c=0;c<tileCols;c++) {
        tiles.push(new Tile(c, r));
      }
    }
  }
  init();

  // animation loop
  let last = performance.now();
  let running = true;
  function loop(now) {
    if (!running) return;
    const dt = (now - last) * 0.06; // scale delta for nicer speeds
    last = now;

    // fade background a bit for trails
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.fillRect(0,0,w,h);

    // draw tiles content
    for (let t of tiles) {
      t.update(dt);
      t.draw(ctx);
    }

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // interactions
  const danger = document.getElementById('danger');
  danger.addEventListener('click', () => {
    running = !running;
    if (running) {
      last = performance.now();
      requestAnimationFrame(loop);
      danger.textContent = '⚠️ لقد تم اختراق جهازك ⚠️';
    } else {
      danger.textContent = 'Paused — اضغط لاستئناف';
    }
  });

  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      running = false;
      ctx.clearRect(0,0,w,h);
      danger.textContent = 'Animation stopped — أغلق التاب';
    }
  });

  // small random glitches: occasionally shift chars inside tiles
  setInterval(() => {
    for (let t of tiles) {
      if (Math.random() < 0.08) {
        // modify a few chars in a tile
        for (let i=0;i<Math.min(3, t.stream.length); i++) {
          t.stream[Math.floor(Math.random()*t.stream.length)].ch = randomChar();
        }
      }
    }
  }, 420);

})();
</script>
</body>
</html>
